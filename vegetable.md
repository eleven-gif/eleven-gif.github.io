# I Good Vegetable

## os

1. 物理内存，虚拟内存，页映射，虚拟内存会不会对gc产生影响？

物理内存就是你的机器本身内存了（如内存条的大小）。物理内存就是CPU的地址线可以直接进行寻址的内存空间大小。

虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，当内存占用完时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。比如说当电脑要读取一个比物理内存还要大的文件时，就要用到虚拟内存，文件被内存读取之后就会先储存到虚拟内存，等待内存把文件全部储存到虚拟内存之后，就把虚拟内里储存的文件释放到原来的目录里了。虚拟内存并不是把硬盘当作内存，而是在硬盘上创建的交换文件。内存用光时lru替换。

在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。

虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。

mmap是用来建立从虚拟空间到磁盘空间的映射的，可以将一个虚拟空间地址映射到一个磁盘文件上，当不设置这个地址时，则由系统自动设置，函数返回对应的内存地址（虚拟地址），当访问这个地址的时候，就需要把磁盘上的内容拷贝到内存了，然后就可以读或者写，最后通过manmap可以将内存上的数据换回到磁盘，也就是解除虚拟空间和内存空间的映射，这也是一种读写磁盘文件的方法，也是一种进程共享数据的方法 共享内存

虚拟内存>物理内存引发swap不是gc

虚拟地址：安全(只会映射安全的物理空间)、高效、便于管理；多级分页压缩空间

mmap：实现不同进程间的文件共享
常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程

减少拷贝次数、用户态与内核态共享内存、不同进程共享内存、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。

2. 进程、线程、协程

进程是系统资源分配的最小单位, 系统由一个个进程(程序)组成 一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。

线程是CPU调度的最小单位

线程属于进程

线程共享进程的内存地址空间

线程几乎不占有系统资源

通信问题:   进程相当于一个容器,而线程而是运行在容器里面的,因此对于容器内的东西,线程是共同享有的,因此线程间的通信可以直接通过全局变量进行通信,但是由此带来的例如多个线程读写同一个地址变量的时候则将带来不可预期的后果,因此这时候引入了各种锁的作用,例如互斥锁等。

进程切换三步，线程后两步

切换页目录以使用新的地址空间、切换内核栈、切换硬件上下文

协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等
协没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.

原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。

协程举例：在Python中，使用了yield的函数为生成器函数，即可以多次返回值。则生成器可以暂停一下，转而执行其他代码，再回来继续执行函数往下的代码。

进程间通信方式：共享内存最快

匿名管道（pipe）、有名管道（FIFO）、signal、消息队列、共享内存、信号量、socket

进程挂了共享内存是否还存在，为什么？（进程间通信使用的数据结构:管道、socket、共享内存、消息队列、信号量等，是属于内核级的，一旦创建后就由内核管理，若进程不对其主动释放，那么这些变量会一直存在，除非重启系统。）


匿名管道和有名管道总结：

（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。

（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。

（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。

数据库中死锁情况：交叉访问两表、并发查询&修改同一条记录、索引不当引发全表扫描（行锁升级为表锁）

SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。

3. 中断、异常、系统调用

    系统调用（system call）

        应用程序主动向操作系统发出的服务请求

    异常(exception)

        非法指令或者其他原因导致当前指令执行失败   (如：内存出错)后的处理请求

    中断(hardware interrupt)

        来自硬件设备的处理请求

 源头

    中断：外设引起
    异常：应用程序意想不到的行为
    系统调用：应用程序请求操作系统提供服务

响应方式

    中断：异步
    异常：同步
    系统调用：异步或同步

处理机制

    中断：持续，对用户应用程序是透明的
    异常：杀死或者重新执行意想不到的应用程序指令
    系统调用：等待和持续

中断处理机制
硬件处理

    依据内部或者外部事件设置中断标志，然后依据中断向量调用相应的中断服务例程。

软件处理

    首先进行现场保存（由编译器完成），然后进行中断服务处理（中断服务例程完成），接着清除中断标记（中断服务例程），最后进行现场恢复（编译器）。


4. I/O多路复用

5种网络I/O模型，阻塞、非阻塞、I/O多路复用、信号驱动IO、异步I/O

select：跨平台、轮询所有fd（数组默认上限1024，修改需编译内核）、阻塞

poll：链表存储没上限限制、轮询效率低

epoll：使用一个fd管理多个fd，用户fd放到内核的事件表中，只需要copy一次，最多返回maxevents个事件。

LT：支持阻塞与非阻塞，检测事件之后，应用程序可以不立即处理，下次wait还会再次通知。

ET：检测事件之后必须立刻处理，下次不会再通知，只支持非阻塞socket，不对fd进行操作，它就不会再发通知。

ET高效，减少了重复触发，必须非阻塞，防止占用时间过长，epoll通过epoll_ctl注册回调，准备好了之后内核会激活fd，wait时就会拿到通知，不遍历。遇到大量的idle/dead-connection，epoll效率会高很多

kqueue与epoll相似


## network

1. TCP

三次握手，四次挥手；两次握手可以吗？close_wait用处，time_wait原因？
TCP/IP协议集包括应用层,传输层，网络层，网络访问层。

tcp头部最小20字节，最大60字节。
第一次握手：客户端发送网络包，服务端收到->客户端发送正常，服务端接收正常

第二次握手：服务端发包->服务端接收/发送都正常，客户端同理（客户端结论）

第三次握手：同上

fast open，第一个请求发过去请求cookie，服务端返回cookie；直接发数据

防止sync泛洪攻击、提高网络利用率

四次挥手：tcp要支持半关闭链接

    CLOSE_WAIT  表示远程计算器关闭连接，正在等待socket连接的关闭。
    FIN_WAIT_1  表示socket连接关闭，正在关闭连接。
    CLOSING  先关闭本地socket连接，然后关闭远程socket连接，最后等待确认信息。
    LAST_ACK  远程计算器关闭后，等待确认信号。
    FIN_WAIT_2  socket连接关闭后，等待来自远程计算器的关闭信号。
    TIME_WAIT  连接关闭后，等待远程计算器关闭重发。 （2MSL）

可靠性保证：ack、超时重传、滑动窗口及流控、校验和

源/目的端口、32位序列号/确认号、四位头部长度、16位窗口大小20字节

数据包中包含窗口大小，实时更新，一方为0之后，会发探测

客户端最大连接数65535，服务端2^32(ip数)x2^16(port数)
实际连接数：1024以下为保留端口，每个socket占用内存在15~20k之间rmem_max，wmem_max，tcp_rmem，tcp_wmem，tcp_mem

2. UDP

UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

源端口 16位、目的端口 16位、长度 16位、校验和 16位

应用程序选择报文大小，不拆分不合并

基于连接与无连接；对系统资源的要求（TCP较多，UDP少）；UDP程序结构较简单；流模式与数据报模式 ；TCP保证数据正确性，UDP可能丢包；TCP保证数据顺序，UDP不保证。

3. HTTP协议

    应用层：telnet、http、ftp、nfs、smtp
    表示层：定义数据格式及加密
    会话层：如何开始、控制和结束一个会话，对多个双向消息进行控制和管理
    传输层：差错控制协议，tcp、udp、spx
    网络层：多端到端传输包进行定义，ip
    数据链路层：与介质相关
    物理层：物理信息

好处（1）人们可以很容易的讨论和学习协议的规范细节。（2）层间的标准接口方便了工程模块化。（3）创建了一个更好的互连环境。（4）降低了复杂度，使程序更容易修改，产品开发的速度更快。（5）每层利用紧邻的下层服务，更容易记住各层的功能。

四层：应用层、传输层、网际网层、网络接口层

    HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80
    HTTP 是无连接无状态的
    HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。
    HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。

http1，一请求一个链接，1.1链接复用

    1.1多个请求不能叠加，在同一个tcp中，请求顺序执行
    2.0多路复用，一个tcp中同时完成多个http
    2.0二进制分帧：在http与tcp之间，所有帧共享一个8字节首部（长度、类型、标志、保留位），帧为最小传输单位
    消息：比帧大的通讯单位，指逻辑上的http消息，如请求、相应，由一个或多个帧组成
    流：比消息大的通讯单位，tcp中的虚拟通道，承载双向消息，有唯一整数标识符

Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。

https加密过程

    客户端请求服务器获取证书公钥->客户端ssl解析证书(无效警告)->生成随机值->使用公钥加密随机值生成密钥->客户端将密钥发送给服务器->服务器用私钥解密得到随机值->将信息和随机值混合在一起进行加密->发送给客户端

ssl建立过程

    client-hello(支持的加密组件发送给服务器，带着一个随机数)->server-hello(确定加密组件，决定后续算法，生成随机数)->certificate(服务器发送自己证书)->服务端通知客户端完成->客户端验证有效之后非对称加密第三个随机数发送给服务端->服务端客户端用相同的算法加密三个随机数(防爆力)->用这个密钥加密后续消息->双方相互发一遍通知，确认密钥正确


4. DNS&请求过程

发送DNS请求到本地DNS服务器(中国电信、移动)->本地DNS查看缓存记录，有则返回，无则向DNS根服务器进行查询->根服务器没有具体信息，告诉本地DNS去那个域名服务器上继续->本地DNS向域服务器发起请求->域服务器告诉本地DNS域名解析服务器地址->本地DNS请求对应的服务器并缓存结果


## database

1. 索引

    正文内容按照一个特定维度排序存储，这个特定的维度就是聚集索引。
    
    非聚集索引索引项顺序存储，但索引项对应的内容却是随机存储的

b+树一个节点放一页数据，减少io，其实如果只在内存是avl更快

expline 命令查看是否用到了索引通过possible_keys字段，type字段表示速度，range合格，ref最好，extra显示用啥索引

回表查询

    先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。

索引覆盖
    
    只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。

建索引避免回表

为什么mysql使用b+树（InnoDB）？

    B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；
    MySQL 使用 B+ 树是因为数据的遍历在关系型数据库中非常常见，它经常需要处理各个表之间的关系并通过范围查询一些数据；但是 MongoDB 作为面向文档的数据库，与数据之间的关系相比，它更看重以文档为中心的组织方式，所以选择了查询单个文档性能较好的 B 树，这个选择对遍历数据的查询也可以保证可以接受的时延；
    LSM 树是一种专门用来优化写入的数据结构，它将随机写变成了顺序写显著地提高了写入性能，但是却牺牲了读的效率，这与大多数场景需要的特点是不匹配的，所以 MongoDB 最终还是选择读取性能更好的 B 树作为默认的数据结构；

2. 事务

mysql事务隔离级别（脏读、幻读、不可重复读）

    Read uncommitter(未提交读) ： 没有解决任何问题
    Read Committer(提交读) ：解决了脏读问题
    Repeatable Read(可重复读)： 解决了不可重复读和脏读问题（ps:在Innodb情况下，也不可能发生幻读问题）（默认）
    Serializable(串行化) ：脏读、幻读、不可重复读三个问题全部解决了

mvcc

    多版本并发控制，数据保存不同的版本，并发读写之后删除旧版本

3. Innodb vs myIsam

两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁。

    InnoDB 支持事务，MyISAM 不支持事务
    InnoDB 支持外键，而 MyISAM 不支持。
    InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
    InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
    InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

4. 范式

    符合1NF的关系中的每个属性都不可再分
    2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖
    3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖

反范式：增加数据冗余，比如商品表->单价x数量=金额，直接保存金额字段

范式优缺点：

    优点：
    范式化的表减少了数据冗余，数据表更新操作快、占用存储空间少。
    缺点：
    查询时需要对多个表进行关联，查询性能降低。
    更难进行索引优化

反范式优缺点：
    
    优点：
    可以减少表关联
    可以更好进行索引优化
    缺点：
    存在大量冗余数据数据维护成本更高（删除异常，插入异常，更新异常）


5. 各种链接

    内链接：组合两表记录返回交集，全部字段
    左链接：左表全部记录，右表返回复合条件的记录，记录不走的地方为null
    右链接：与左链接相反
    全链接：mysql不支持

    note：mysql认为每次查询都是关联查询，嵌套循环找到所有的匹配行，再提取匹配列


## redis

1. hastable与ziplist转化

- hash-max-ziplist-entries 512：用ziplist最多存512个元素
- hash-max-ziplist-value 64：单个元素超过64字节转成dict


2. rehash

每次移动一定的数量，两个hash表同时存在

3. hgetall 或者说一个hashtable 有很多key，如何优化？

序列化存储，减少遍历hash的性能损失

4. 缓存穿透、击穿、雪崩

穿透：

那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。

针对于一些恶意攻击，攻击带过来的大量key 是不存在的，那么我们采用第一种方案就会缓存大量不存在key的数据。此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些key。针对这种key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。

击穿：

在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。

雪崩：同时失效


5. bloom filter 原理

一个很大的位数组，k个hash函数，对元素进行hash，得到k个值，放到位数组不同位为1，检查是否存在时，同样hash出k个值，只要有一个位不是1，肯定不存在，都是1可能存在

6. 一致性hash

环状结构，影响一个节点，分散多个虚拟节点


## 分布式理解

1. cap原理

2. raft协议

选主、日志同步、配置变更

3. 乐观锁、悲观锁、自旋锁、互斥锁

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。

加版本号解决
